## 一、JavaScript 简介

---

### （一）JavaScript 简史

​	`JavaScript` 诞生于 1995 年，它的初衷是解决表单验证的问题。在没有出现 `JavaScript` 之前，所有的表单验证都要将整个表单提交到后台服务器，由后台来完成验证工作，这无疑是大大的降低了性能和用户体验。然而，浏览器鼻祖的公司 `Netscape` 希望通过 `JavaScript` 来解决这个问题。通过以下的时间节点来初步认识 `JavaScript` ：

- `Brendan Eich` （`JavaScript` 之父）于1995年2月发布 `LiveScript` （`JavaScript` 的前身），但是为了赶进度，`Netscape` 与 `Sun`  公司建立了一个联盟，同时也为了搭上当时热炒的 `Java` 顺风车，决定把 `LiveScript` 改名为 `JavaScript` .
- 微软与 `Navigator` 竞争，抄袭并改名为 `JScript`.
- 市面上同时出现了微软的 `JScript` 和原创的 `JavaScript` ，由于微软的 IE 浏览器是微软操作系统自带的，所以就相当于购买操作系统送浏览器，然而就不会有人去购买 `navigator` 了，所以很快网景公司就倒闭了。
- 在网景公司快倒闭之前，他们把 `JavaScript` 交给了欧洲计算机制造商协会（`ECMA`），他们经过数月的努力完成了 `ECMA-262` —— 定义一种名为 `ECMAScript` 的新脚本语言的标准。

---

### （二）JavaScript 的实现

​	在很多情况下，`JavaScript` 和 `ECMAScript` 通常被认为是一个意思，但其实前者的范围比后者更大，后者是前者的核心。准确的说，**`JavaScript` 包括核心（`ECMAScript`），文档对象模型（`DOM`）和 浏览器对象模型（`BOM`）**。

#### 1. ECMAScript

​	实际上，`ECMAScript` 只是一套标准，它与 `Web` 浏览器没有依赖关系。浏览器只是 `ECMAScript` 实现可能的宿主环境之一，也就是说，`ECMAScript` 并不依赖于浏览器。`ECMAScript` 大致规定了以下内容：

- 语法
- 数据类型
- 语句
- 关键字与保留字
- 操作符
- 对象

#### 2. 文档对象模型（DOM）

​	文档对象模型（`DOM`，`Document Object Model`）是针对 `XML` 但经过扩展用于 `HTML` 的应用程序编程接口。**`DOM` 把整个页面映射为一个多层节点结构**，从而通过获取这些节点（元素）来操作对应的元素。需要注意的是，**`DOM` 并不只是针对 `JavaScript` 的，很多别的语言也都实现了 `DOM` 。** `DOM` 还分为以下的几个级别，每个级别都提供了不同的功能和实现：

- `DOM 1` —— 由两个模块组成：`DOM Core` 和 `DOM HTML` 。其中，前者规定何如映射文档结构，以便简化对文档中任意部分的访问和操作；后者在前者的基础上加以扩展，添加了针对 `HTML` 的对象和方法。
- `DOM 2` —— 由四个模块组成：
  - `DOM Views`，定义了跟踪不同文档
  - `DOM Events`，定义了事件和事件处理的接口
  - `DOM Style`，定义了基于 `CSS` 为元素应用样式的接口
  - `DOM Traversal and Range`，定义了遍历和操作文档树的接口

- `DOM 3` —— 引入了统一加载和保存文档的方法（`DOM Load and Save`）；验证文档的方法（`DOM Validation`）

#### 3. 浏览器对象模型（BOM）

​	浏览器对象模型用于支持访问和操作浏览器窗口的API。具体体现为以下几个对象：

- `window` —— 浏览器窗口
- `location` —— 浏览器地址栏
- `screen` —— 显示屏
- `history` —— 历史记录
- `navagator` —— 导航

---

## 二、在 HTML 中使用 JavaScript

​	如果要在 `HTML` 中使用 `JavaScript` ，那么方法只有一个，就是通过 `script` 标签实现的。实现的方式有以下两种：

- 方式一：直接在标签体内书写js代码

```html
    <script>
        function(){
            console.log("hello js");
        }
    </script>
```

- 方式二：通过src属性引入（可以是远程的路径，也可以是本地的相对路径）

  ```html
  <script src="路径"></script>
  ```

无论用哪种方式引入，都需要注意脚本加载与页面渲染的问题，因为很多时候引入js脚本都是为了操作页面元素（就是操作`DOM`），所以必然会存在加载先后的问题，正确的加载顺序是必须先生成文档DOM树，再执行js代码。一旦这个顺序反了，也就是说，DOM树根本没有挂载到页面上，js脚本就执行了，那么所有的操作都是无效的。解决这个问题的方式有很多种：

① 简单粗暴的方法就是将 `script` 标签写在 `body` 的最后，那么一旦加载到最后，页面上所有的元素都完成加载了，DOM也渲染完毕，此时操作 DOM 必然没有问题。

② 通过js代码监听 DOM 的加载

```js
//这是一个回调函数，在页面渲染完毕后执行
window.onload = function(){
    //此处写js代码
}
```

③ 给 `script` 标签设置 `defer` 属性，但这种方式只适用于外部脚本。

```html
//这个属性的用途是标明脚本在执行时不会影响页面构造，也就是说，脚本会被延迟到整个页面都解析完毕后再执行
<script defer></script>
```

---

## 三、基本概念

### （一）语法

- 区分大小写
- 标识符可以包含字母，数字，下划线，美元符号$，但不能以数字开头，不能使用关键字和保留字。
- //表示单行注释，/**/ 表示多行注释。
- 语句结尾可以省略分号，也可以带上分号。

### （二）变量

​	`ECMAScript` 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量的方式有以下几种：

- 使用 `var` 关键字

  ```js
  //语法： var 变量名; 如果只声明没有初始化，那么默认值为 undefined
  var a;
  //当然，也可以同时进行赋值
  var a = 1;
  ```

- 使用 `const` 关键字

  ```js
  //使用const定义的变量一旦初始化就不能修改
  const price = 10;
  price = 9;//报错，不能修改
  ```

- 使用 `let` 关键字 （用法大致与`var`一致，区别看后面）

  ```js
  let a;
  let a = 1;
  ```

- 不使用任何关键字

  ```js
  a = 1;//如果不使用关键字定义变量，那么该变量会被认为是 window 对象下的，也就说，这是个全局变量
  console.log(window.a);//输出1
  ```

注意：

1. `let` 和 `const` 两个关键字是 `ES6` 新增的语法，与 `var` 的区别是它们拥有块级作用域。

2. `const` 定义的变量一旦初始化后就不能被修改，但这不代表 `const` 仅仅用于定义常量！！如果一个变量已经很明确的预知未来不会改变或者不期望被改变，也可以使用 `const` 定义。例如，获取后台返回的结果。最后还需要注意的是“修改”，指的是引入内存地址是否可变，而不是内容是否可修改！！举例：

   ```js
   const arr = [1,2,3,4];//使用const定义一个数组
   arr.push(5);//在数组的最后添加一个元素5
   ```

   注意，以上这两行代码是可以通过的，因为数组属于引用类型的数据，变量 `arr` 存储的是数组在内存中的地址，第二行代码虽然修改了数组里面的内容，但是变量的内存地址没有被修改，所以这是可行的。同理，修改一个对象里面的内容也是可以的。但是不能像下面这样修改：

   ```js
   const arr = [1,2,3,4];
   arr = [1,2,3,4,5]//报错
   ```

3. 使用 `var` 声明的变量会被提前到脚本的最顶端，也就是说，会被提前解释！！比如：

   ```html
   //运行结果：报错，因为变量a没有定义
   <script>
   	console.log(a);
   </script>
   
   //运行结果：不报错，打印输出 undefined
   <script>
   	console.log(a);
       var a;
   </script>
   
   //运行结果：不报错，打印输出 undefined
   <script>
   	console.log(a);
       var a = 1;
   </script>
   ```

总结：所有使用 `var` 关键字定义的变量都会被优先提取到代码的最前解析，但不会初始化！意思就是，解析器帮你在代码的最前面定义了所有变量，初始值为 `undefined` ，然后执行到具体的地方再进行赋值。就拿上面的第三个例子为例，在解析器的眼里，它的顺序是这样的：

```html
<script>
	var a;
    console.log(a);
    a = 1;
</script>
```

专业术语称这种想象为变量的提升，详细的内容在后面再介绍。

### （三）数据类型

#### 1. 数据类型概括

​	`ES` 中一共有7种数组类型，其中包含5种基本数据类型：`String、Number、Boolean、Null、Undefined`，1种引用类型 `Object` ，最后一种是 `ES6` 新增的类型 `Symbol` 。

- `String` 类型：用于表示由零或多个字符组成的字符序列。注意：`JS` 并没有明确区分字符和字符串，一律都被认为是 `String` 类型，可以使用单引号和双引号来表示。
- `Number` 类型：用于表示数值，没有区分整型和浮点型，所有的数值都被认为是 `Number` 类型。
- `Boolean` 类型：表示布尔值，只有 `true` 和 `false` 两个值。
- `Null` 类型，表示空值，只有一个值 `null`。
- `Undefined` 类型，只有一个值 `undefined` 。在使用关键字声明变量但未对其进行初始化赋值时，这时候变量的值就是 `undefined`；或者访问一个对象中没有的属性，这时候也是 `undefined`；函数形参的默认值是 `undefined` 。

#### 2. typeof 运算符

​	上面五种称为基本数据类型，剩下两种在后面再介绍。在 `JS` 中，因为变量类型是松散的，因此需要一种手段来检测给定变量的数据类型：`typeof` 运算符。

语法：`typeof 变量` 

返回值：

- 如果变量保存的是一个字符串，则返回 `string` 

- 如果变量保存的是一个数值，则返回 `number`
- 如果变量保存的是一个布尔值，则返回 `boolean`
- 如果变量保存的是一个 `undefined` ，则返回 `undefined`
- 如果变量保存的是一个 `null`，则返回 `object`
- 如果变量保存的是一个普通对象，则返回 `object`
- 如果变量保存的是一个函数，则返回 `funciton`

注意：对象和 `null` 返回的都是 `object` ，所以并不能通过 `typeof` 运算符来检测 `null` 或 `Object`。如果需要判断一个值是否为 `null` 可以使用全等运算符 `===` ：

```js
let a = null;
if(a === null){//true
    console.log("hello js");
}
```

另外，如果需要检测一个 `Object` ，则可以通过 `instanceof` 运算符。

语法：`A instanceof B`

作用：检测 A 是否是 B 的实例对象。返回值是布尔值。

#### 3. 数据类型之间的相互转换

​	了解数据类型以及熟悉它们之间是如何转换是非常重要的，这里说的转换是指 `String、Number、Boolean` 三者之间的相互转换，因为对于另外两个只有一个值的基本类型，也没有转换的价值和意义了。 在 `JS` 中有两种转换方式：

- **显示类型转换 —— 使用对应的强制转换函数**

  - 其他类型转换为 `String` 类型

    使用 `String()` 方法，例如：

    ```js
    var a = 123;
    var b = String(a);//此时b的值是123,但是它是字符串的123 也就相当于 "123"
    ```

  - 其他类型转换为 `Number` 类型

    使用 `Number()` 方法，例如：

    ```js
    var a = "123";
    var b = Number(a);//此时b的值是123，但是它是数值类型的123
    ```

  - 其他类型转换为 `Boolean` 类型

    使用 `Boolean()` 方法

- **隐式类型转换**

  - 其他类型转换为 `String` 类型

    **利用字符串加法拼串的规则，通过空串 “” 与其他类型做加法运算**，例如：

    ```js
    var a = 123;
    var b = "" + 123;//此时b的值是123，但是它是字符串的123
    ```

  - 其他类型转换为 `Number` 类型

    **利用一元运算符 +** 

    ```js
    var a = "123";
    var b = +a;//此时b的值是123，但是它是数值类型的
    ```

  - 其他类型转换为 `Boolean` 类型

    **两次逻辑取反**

    ```js
    var a = 123;
    var b = !!a;//b已经变为一个布尔值true了
    ```

注意：

​	其他类型转为数值类型的时候需要注意，正常的 "123","123456" 这种字符里面仅仅包含数字的可以转换为对应的字符串，对于其他包含其他非数字字符的字符串，或者是布尔值，此时转换的结果为 `NaN` ，`NaN` 是数值类型的一个特殊代表，它属于数值类型，表示一个数值是非法数值，`NaN` 意为 `Not a Number`。但是，如果对于那种前面部分是数值，后面部分是其他字符的字符串，例如："123abc"，"123.456abd"，则可以通过 `parseInt()` 和 `parseFloat()` 来进行提取，这两个函数会尽最大可能提取字符串中的数值，一旦遇到其他类型则结束提取并返回结果。

### （四）操作符

#### 1. 算术运算符

`+ - * / ` ：表示加减乘除，与上学的运算法则一致。

% ： 表示求余数。

`**` ：乘方，例如 2的3次方可以表示为 `2**3` ，这是 `ES7` 新增语法。

#### 2. 比较运算符

`< > >= <= ` ：分别表示小于，大于，大于等于，小于等于。如果是两个数值做比较，规则跟小学的一致，比较数值大小；如果是两个字符串比较，则会逐一比较字符的编码大小。

#### 3. 相等运算符

`==` ：表示相等，判断的是两个操作数会自动的做数据类型转换，尽量转换为相同的类型再做比较，比如 "123" == 123 ，结果为 `true` 

`===` ：全等运算符，不仅会比较两个操作数是否一致，还会比较数据类型是否一致。比如 "123" === 123，结果为 `false`

注意：比较两个对象时，比较的是它们的内存地址是否一致。

#### 4. 一元运算符

`+ -`：分别表示取正，取负。作用在前面做数据类型转换的时候已经体现了。

#### 5. 逻辑运算符

`!` ：逻辑取反

`&&` ：逻辑与

`||` ：逻辑或

注意：在 `JS` 中，如果比较的两个操作数不是布尔值，而是其他类型的值，则返回的结果是影响整个表达式结果的那个值，比如：

`1 && 2` 的结果不是 `true` ，而是 2

`0 && 1` 的结果不是 `false` ，而是 0

#### 6. 赋值运算符

`= += -= *= /=` 

#### 7. 三元运算符

语法：（条件表达式）？表达式1 ：表达式2；

作用：先判断调价表达式是否正确，正确则执行表达式1，否则执行表达式2。

可嵌套使用。

### （五）语句

#### 1. if 语句

```js
if(条件表达式){
   
}else if(条件表达式){
         
}else{
    
}
```

#### 2. for 语句

```js
for(初始表达式；条件表达式；迭代条件){
    //循环体
}
```

#### 3. while 语句

```js
while(条件表达式){
    //循环体
    //迭代条件
}

do{
    //循环体
}while(条件表达式)
```

#### 4. switch 语句

```js
switch(变量){
    case 值1:
        语句1；
        break;
    case 值2：
        语句2；
        break;
    default:
        语句n;
}
```

注意：

1. 值1 ...值n 与变量是做全等判断的，所以不仅要注意数值是否一致，还要注意数据类型。

2. 注意添加 `break` 关键字。如果没有，则会从匹配的那个语句开始往下执行所有的语句。

3. `break` 关键字除了可以跳出 `switch-case` 语句以外，还可以用来跳出循环，但注意 `continue` 的区别，`continue` 是跳出当次的循环，而`break` 是跳出当前的循环，举例：

   ```js
   for(let i = 0;i < 5;i++){
       if(i === 2){
           continue;
       }
       console.log(i);
   }
   //以上这段代码输出的结果是 0 1 3 4 因为 i为2的时候被continue跳出了循环
   
   for(let i = 0;i < 5;i++){
       if(i === 2){
           break;
       }
       console.log(i);
   }
   //以上这段代码输出的结果是 0 1 因为i为2的时候已经跳出了整个循环。
   ```

---

## 四、对象

### （一）对象的定义及分类

​	对象，从数据类型上看它属于引用数据类型（区别于基本数据类型，详细区别往下看），是一种用于存储键值对数据的容器，其中键必须唯一，同一个对象中不能出现同样的键。其中，键又称为属性，值称为属性值。它是 `JS` 中常用而且重要的一个数据类型，它可以分为以下三种：

1. `ES`内建对象
2. 宿主对象
3. 自定义对象

其中，`ES`内建是指 `ECMAScript` 标准给我们定义的对象，比如，数组，函数，正则表达式，日期时间对象等等；宿主对象主要指 `DOM` 和 `BOM` ；自定义对象就是我们开发者自己定义的对象，也是普通的对象。一般情况下，如果没有特指，对象就是指自定义对象。

### （二）基本使用

#### 1. 创建对象

创建对象的方式有以下几种：

- `new Object()`

  ```js
  let obj = new Object();//obj 就是一个空对象
  ```

- 对象字面量（这是最直接，也是最常用的方式）

  ```js
  let obj = {};
  ```

- 构造函数

  因为没有介绍函数，所以先略过。

#### 2. 添加/修改键值对

添加或修改键值对的方式有三种：

- 方式一：**直接在创建对象的时候赋值**

  ```js
  let obj = {a:123,b:"456"};
  ```

- 方式二：**通过 对象.属性名的方式赋值**

  ```js
  let obj = {};
  obj.a = 123;
  obj.b = "456";
  ```

- 方式三：**通过 对象[变量] 的方式赋值**

  ```js
  let obj = {};
  let key = "a";
  obj[key] = 123;
  ```

注意：如果属性已存在，则赋值操作就是修改以前存在的值；如果属性不存在，则添加属性。

#### 3. 访问对象中的属性

与上面添加/修改的大致一样，只是不赋值而已。

- 对象.属性名访问具体的属性
- 对象[变量] 访问具体的属性

### （三）**基本数据类型与引用数据类型的区别（重要）

先来回顾以下几个概念：

- 数据类型：为了更好的描述数据，从而将数据分为不同的类型，然而数据类型就是它们的统称，在 `ES` 中一共有 7 种数据类型，其中包含 5 中基本数据类型和1种引用数据类型和`ES6`新增的数据类型 `Symbol`。
- 基本数据类型：`String、Number、Boolean、Undefined、Null`
- 引用数据类型：`Object`
- 独立于基本数据类型和引用数据类型的大佬：`Symbol`

![](C:\Users\jonas\Desktop\读书笔记\images\数据类型.png)

先来看基本数据类型：

```js
var a = 1;
```

上面这是一行非常简单的代码，但是从解释器的角度来看，做了不少功夫了：

​	首先，关键字 `var` 声明的变量会存在**变量提升**的问题，也就是说，上面的一行代码会被解释器这样来解释：①先在解释之前声明变量a（初始值为 `undefined`）② 解释到代码所在行进行初始化赋值 a = 1。

​	在内存中的体现：① 在栈内存（内存的一种结构，用于存放基本数据类型和指针）中开辟一个空间，空间中有一个变量 a ，初始值为 `undefined` ② 初始化赋值，将 `undefined` 改为 1。

​	图示：

​	![](C:\Users\jonas\Desktop\读书笔记\images\基本数据类型的解释过程.png)

引用数据类型：

```js
var obj = {name:"jonas",age:18}
var obj2 = obj;
obj2.name = "jerry"
```

先来简单分析上面的三行代码，第一行，定义了一个对象obj，储存了两个键值对；第二行，将obj赋值给 obj2；然后这obj2访问了name属性并修改为 jerry，那么obj中的name是什么呢？还是原来的 jonas 还是 jerry呢？还有，obj 赋值给 obj2 的是什么呢？从解释器的角度和内存结构来看上面这三行代码：

首先，因为存在关键字，所以必然存在变量提升的现象，也就是最开始就在栈内存中开辟了两块空间，一个是 obj 的，一个是 obj2 的。

解释到代码obj所在行，发现它是一个对象，则去堆内存（内存的另外一种结构，区别于栈内存，堆内存是存储引用数据类型的空间）中开辟一个空间，然后在里面储存键值对，并将这个堆内存的地址（堆内存的地址是一个16进制数，例如：0x1234）交给栈内存中的变量 obj 来保存。

接着，第二行代码，将 obj 的值赋值给变量 obj2 ，由上面知道，变量 obj 保存的是一个 16进制数（堆内存的地址），所以赋值也就是将这个值赋值给 obj2 。注意：此时的现象是，obj 和 obj2 两个变量都保存了同一个内存地址值，也就是说，它们引用着同一个对象！！！所以无论通过哪个变量来访问对象其实操作的都是内存中的同一个对象。

由上面的分析，很显然如果通过 obj2 来访问对象的属性并且改变了值，那么正直改变的是堆内存中对象里面的内容，而 obj 和 obj2 都是保存着这个对象的引用地址。

图示：

![](C:\Users\jonas\Desktop\读书笔记\images\引用数据类型的解释过程.png)

结论：

1. 基本数据类型直接存储在栈内存中，引用数据类型存储在堆内存中，通过栈内存的一个变量（存储一个内存地址值）来引用堆内存的对象。
2. 如果修改一个保存基本数据类型的变量，则直接在栈内存中修改；如果修改对象，则通过引用修改对象的内容，栈内存中变量保存的依然是个地址值。
3. == 判断两个基本类型，则判断他们的内容是否一致；如果判断的是两个引用类型变量，则判断他们保存的内存地址是否一致。

---

## 五、函数

### （一）函数的定义及分类

​	函数，从数据类型上看属于引用数据类型，对象的一种。函数是特殊的对象，使用函数能实现特定的功能，所以，函数就是特定功能的代码片段。在 `ES` 中，函数可大致分为：

- 内置函数，比如前面用于类型转换的 `String()、Number()等等`。
- 构造函数，用于批量创建对象，前面讲创建对象的时候提过。
- 自定义函数，开发者自定义，用于实现某些特定功能。

### （二）基本使用

定义函数的方式有以下两种：

- 方式一：使用 `var` 关键字定义一个变量，变量保存的是一个函数

  ```js
  var foo = function(){
      console.log("hello js");
  }
  ```

- 方式二：函数声明，直接使用关键字 `function` 声明函数（常用的方式）

  ```js
  function foo(){
      console.log("hello js")
  }
  ```

注意：上面两种方式是不同的，方式一使用了 `var` 关键字定义，所以底层的原理跟上面介绍引用类型的时候是一致的；而方式二会存在函数提升（类似于变量提升）的现象。举例：

```js
foo();//报错，foo is not a function 
bar();//输出 hello bar

var foo = function(){
    console.log("hello foo");
}

function bar(){
    console.log("hello bar");
}
```

造成这种现象的原因还是跟前面分析的大致相同，因为 `var` 定义的变量 `foo` 被提升，但此时未进行初始化，默认值是 `undefined`，到了代码所在行才对 `foo` 进行赋值（赋值为一个函数，foo保存堆空间地址值）。然而，函数 `bar` 被提前解释了，也就是说，解释器一来就将它解析了（这种现象称为函数提升），所以无论在什么地方都可以调用。

总结：

尽量使用方式二去声明函数，因为无论在哪里声明（同一个文件下）都可以调用，不用考虑先后问题；如果使用第一种，则需要考虑变量提升的问题。

### （三）函数的参数

#### 1. 参数的分类

函数的参数可分为形参和实参。定义函数时声明的参数称为形参，调用函数传递进去的称为实参。例如：

```js
function foo(a){//此处的a就是形参
    console.log(a);
}

foo(1);//此处的1就是实参
```

#### 2. 参数的默认值

在 `ES6` 的语法中，允许函数的参数提供默认值，如果参数没有对应的实参传过来值，那么就使用参数的默认值，如果参数没有指定默认值，那么就是 `undefined`。

举例：

```js
function foo(a=1,b=1){//指定了参数a的默认值是1
    return a+b;
}

foo(2,2);//返回的结果为4
foo(2);//返回结果为3
```

#### 3. 不定长参数

有时候函数参数的个数是不确定的，那么此时就可以使用不定长参数。同时，如果函数中存在某个或多个参数是固定的，那么这些固定的参数在声明在前面，不定长的参数必须声明在最后。举例：求多个和的和

```js
function bar(a,b,...args){//使用 ...变量名 表示不定长参数
    let sum = 0
    args.forEach(function(item){//变量 args 的引用就是一个包含不定长参数的数组
        sum += item
    })
    return sum + a + b
}

bar(1,2,3,4,5)//结果为15
```

注意：

1. 不定长参数在一个函数中只能有一个
2. 不定长参数一定要写在参数列表的最后
3. 不定长参数的语法为 ...变量名，这个变量引用的其实就是一个数组

#### 4. 实参列表 arguments

`arguments` 是一个伪数组（很像数组，但不是数组），它能通过索引下标获取里面的元素，也有 `length` 属性。它里面的元素就是所有的实参。也就是说，所有的实参都可以通过 `arguments` 来获取。

```js
function bar(a,b,...args){//arguments 在函数中直接使用就可以了，不需要声明参数或另外的操作。
    for(let i = 0;i < arguments.length;i++){
        console.log(arguments[i])
    }
}
bar(1,2,3,4,5,6)//输出 1 2 3 4 5 6
```

#### 5. 匿名函数

匿名的意思跟现实中一致，就是没有名字或者不提供名字，那么问题来了，调用函数的时候不是需要通过 函数名() 这样的方式来调用吗，那名字都没有了怎么调用？正因为这样，所以，匿名函数的使用场景常见的只有两种：

- 自调用函数：在定义函数的时候就立马调用

  ```js
  (function () {
      console.log("hello js")
  })();
  ```

  第一个圆括号包裹着一个函数的定义，后面的圆括号表示调用该函数，当然，你也可以指定参数。

- 回调函数

  回调函数就是当程序达到某个状态或达到某个时刻触发的，这种函数是由解释器调用的，并且实参都是由解释器提供的。总结一句话就是：我们定义的，但由解释器调用的函数就是回调函数。常见的有，事件回调函数，定时器，延迟调用等等。后面再详细介绍。

#### 6. 函数的返回值

​	函数的返回值与其他语言一致都是使用 `return` 关键字来返回的。需要注意的是，在 `return` 关键字后的代码不会执行了。

#### 7. 构造函数

​	构造函数其实也是普通的函数，它与普通的函数区别在于它是由于“生产”对象的，也就是说，它的返回值是一个对象。这就是前面说创建对象的时候提到的第三种方式。

首先，为了让构造函数与普通的函数区分开，`JS` 约定构造函数以大写字母开头，其余普通的函数名以小写字母开头，但是，这不是区分它们的条件。在函数定义时是没有办法区分哪个是构造函数，哪个是普通的函数，只有在调用的时候才能区分，因为普通的函数调用就是 函数名()；然而，构造函数是要用关键字 `new` 来调用的。示例：

```js
function Person(name,age){//一个用于生产人这种对象的函数，参数为姓名和年龄
    this.name = name;
    this.age = age;
}

let p = new Person("jonas",18);//这就创建了一个person对象了
```

看完了你可能会问：

1. `Person` 函数中的 `this` 是什么？
2. `Person` 函数中没有使用 `return` 关键字来返回一个对象啊，那么这个对象是从哪里来的？

回答上面两个问题其实只需要搞清楚关键字 `new` 的原理就可以了：

1. 创建一个新的对象 `{}`
2. 将函数中的 `this` 指向这个对象
3. 执行函数体代码
4. 返回这个对象

所以上面的变量p ，就是拿到了一个对象的引用地址，在对象的堆空间中就存在着这么一个对象。

然而，如果使用这种方式来创建对象太麻烦了，因为普通的对象直接 `{}` 就创建完事了。那么，这种方式的意义何在呢？这种方式是针对需要产生一批相同或者相类似的对象，比如说，有这么个构造函数，用于描述具体某个公司的员工，那么公司名必然是固定的，那么员工的具体信息就通过参数的方式来改变，此时就可以通过这种方式来创建对象了：

```js
function Employee(name,age){
    this.name = name;
    this.age = age;
    this.company = "Autumn Meet";//我的淘宝店，淘宝搜秋遇了解一下
}
```

那么通过上面这个函数创建的对象在堆空间中都有一个 `company` 属性了。那么问题来了，假如里面有很多个属性都是固定或者大家都一样的呢，这无疑就是在浪费堆空间的资源，所以，这样是不可取的。解决的方法就是下面的内容。

#### 8. ***原型与原型链 （重要）

​	对于上面的问题，设计者早就替我们像好了，其实每个函数上默认都有一个属性 `prototype`，这个属性指向的一个对象，这个对象就是原型对象。这个对象可以被认为是一个公共的区域，因为对于同一个构造函数产生的对象，它们的原型对象都是同一个对象。示例：

```js
//构造函数
function Person(name,age){
    this.name = name;
    this.age = age;
}
Person.prototype.company = "Autumn Meet";//在原型对象上添加了一个属性
//通过构造函数产生两个对象
let p1 = new Person("jonas",18);
let p2 = new Person("jerry",19);
```

过程图示：

![](C:\Users\jonas\Desktop\读书笔记\images\原型对象.png)

总结：

1. 所有函数都有一个 `prototype` 属性，该属性指向的就是原型对象。
2. 由同一个构造函数创建的对象，它们的 `__proto__` （注意前后都是两个下划线）属性指向的是它们函数的原型对象。
3. 原型对象可以被认为是公共区域，存放一些共有的属性或方法。

那么问题又来了，既然所有的对象都有 `__proto__` 属性，那么原型对象有没有呢？答案是有的。指向的对象也是原型对象，那不会无尽止的创建对象？那这倒不会，一直到 `Object` 的原型就没有原型了（该值为 `null`）。从而，这一系列的原型对象构成的就被称为原型链。

**访问一个对象中的属性，先在对象内部查找，如果没有，则会去最近一级的原型对象上查找，一直查找到 `Object` 的原型，如果还是没有，则返回 `undefined` ，所以注意，访问一个不存在的属性并不会报错，而是返回 `undefined` 。**

#### 9. 箭头函数

箭头函数是 `ES6` 新增的语法，提供了定义函数的一种新的方式：

```js
var foo = (参数) => {
    //函数体
}
```

**如果参数只有一个，则原括号可以省略；如果函数体只有一行代码，则可以省略花括号，并且会将这行代码的结果作为返回值返回。**

除此以外，箭头函数还有一个非常重要的特征就是，它的内部 `this` 指向的是当前上下文环境。

---

## 六、数组

### （一）数组的定义及使用

数组是 `JS` 中最常用的数据类型之一，与对象相似的是，它也是存储数据的集合，但是它是有序的集合。有序体现为它是通过索引下标取值。创建数组的方式有以下两种：

- 通过构造函数创建：`new Array()` （一般不使用）
- 通过字面量的方式创建：`[]` （常用的方式）

通过 `length` 属性可以获取数组的长度。

注意：

不能通过 `typeof` 运算符来检测数组，因为 `typeof Array === object`；可以使用 `arr instanceof Array` 或者 `Array.isArray(arr)` 来判断 `arr` 是否为数组。

### （二）常用方法

#### 1. 转换方法

- `toString()` ：

  返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。例如：

  ```js
  let arr = [1,2,3,4]
  console.log(arr.toString())//输出 1,2,3,4
  ```

- `valueOf()` ：

  返回数组本身（不会产生新的数组，拿的是同一个引用）

#### 2. 栈方法

- `push(element)` ：

  向数组的末尾添加元素，而且该方法可以接收任意数量的参数，把它们逐个添加到数组末尾。该方法会改变原数组！！

  返回值：修改后数组的长度。

- `pop()` ：

  删除数组最后一个元素，该方法会改变原数组！！

  返回值：被删除的那个元素。

#### 3. 队列方法

- `shift()` ：

  删除数组的第一个元素，该方法会改变原数组！！

  返回值：被删除的那个元素。

- `unshift(element)` ：

  向数组的前面（索引为0处）插入元素，同样的，该方法也可以接收任意多个参数。该方法会改变原数组！！

  返回值：修改后数组的长度。

#### 4. 重排序方法

- `reverse()` ：

  反转数组中的元素，该方法会改变原数组

- `sort()`：

  默认按照 `ASCII码` 升序排列数组中的元素。参数可接收一个带有两个参数的函数，这两个参数就是数组中的随意两个元素（每次取的结果不一样，可以肯定的是不会重复取同一个，而且第一个参数肯定在第二个参数的前面）。如果函数的返回值大于0，则交互两个参数在数组中的位置。 

#### 5. 操作方法

- `concat(element)` ：

  该方法用于添加元素，该方法可以接收多个参数。先创建一个原数组的副本，如果参数为数组，则将数组中的所有元素添加到副本数组，如果为其他类型的数据，则直接添加到副本数组中。返回值就是这个副本数组。

  注意：该方法不会改变原数组。

  另外：实现这种添加效果可以考虑使用 `ES6` 的 `...` 三点运算符方法。

- `slice(start,end)`：

  该方法用于截取数组，第二个参数不是必须的，如果不传，则一直截取到数组的末尾；如果有第二个参数，则截取数组的 [start,end) 的前闭后开区间的元素。

  注意：该方法不会改变原数组，而是返回一个新的数组。

- `splice(start,count,...args)`

  这是一个多功能方法：

  - 删除：

    如果只传了前两个参数，则表示删除，从 `start` 索引开始删除 `count` 个元素

  - 插入/替换：

    需要提供3个或以上的参数，该方法可以接收任意多个参数，如果只需要插入，则第二个参数须为0，表示删除0个。如果需要替换，则指定第二个参数表示删除多少个元素。

  注意：该方法会改变原数组！！返回值是被删除的元素组成的数组。

#### 6. 位置方法

- `indexOf(element,start)` ：

  在数组中从 `start`索引位置开始查找元素 `element` ，如果能查到，则返回元素的索引；如果不存在，则返回 -1 。第二个参数不是必须的，如果不传，则从0开始。

- `lastIndexOf(element,start)`：

  与上面的一致，不同的是从数组的末尾往回找。 

#### 7. 迭代方法（重要）

- `forEach()`
- `map()`
- `filter()`

上面的三个方法都用于遍历数组，参数都是一个回调函数，回调函数接收三个参数（但一般只使用前两个），第一个表示元素本身，第二个表示元素的索引。第一个方法仅仅为最纯粹的遍历。第二个方法用于加工数组中的所有元素，最后一个用于过滤数组中的元素。具体使用如下：

```js
let arr = [1,2,3,4]
arr.forEach(function (item,index) {
    console.log("索引: " + index + "---" + item)
})

let arr1 = arr.filter(function (item) {
    return item > 2;//过滤掉不满足条件的，剩下的都是满足这个条件的
})

let arr2 = arr.map(function (item) {
    return item *2;
})
```

注意：

**他们都不会改变原数组，而是返回一个新的数组。**

#### 8. from()

`from()` 是 `ES6` 新增的方法，用于将类数组（伪数组）或可迭代的集合转换为数组。返回值就是一个转换后的数组。

如果不用这个方法，还可以使用 `ES5` 的方法：

```js
[].slice.calll(arr)//将arr转换为数组
```

---

## 七、时间类型

​	时间类型是最简单的一种了，没有太多的方法，都是一些比较简单的方法，所以这里就简单概括了。

- 创建时间对象

  ```js
  let date = new Date();
  ```

  空参则表示根据当前的时间节点创建一个时间对象，如果在控制台输出 `date` 会得到这样的结果：`Thu Jun 27 2019 19:28:31 GMT+0800 (中国标准时间)`，这是没有什么问题，但是这种时间往往不是我们所需要的，我们需要的可能是 年-月-日-时-分-秒 或者其他格式的时间。那么只需要使用下面的方法来进行拼串就可以了：

- 常用方法
  - `getTime()` —— 时间戳（单位：毫秒）
  - `getFullYear()` —— 获取年份（4位数）
  - `getMonth()` —— 获取月份，其中0表示一月，11表示十二月
  - `getDate()` —— 获取日期
  - `getDay()` —— 获取日期中星期的星期几（0表示周日，6表示周六）
  - `getHours()` —— 获取时（0-23）
  - `getMinutes()` —— 获取分钟
  - `getSecounds()` —— 获取秒

---

## 八、正则表达式

​	`ES` 通过 `RegExp` 类型来支持正则表达式。但是一般不会显示创建对象，而是使用字面量的方式创建正则：

```js
let expression = /pattern/flags;
```

其中，`pattern` 称为模式，其实就是正则表达式；`flags` 称为标志，可选值为：

- `g` —— 表示全局的，即应用于所有字符串，而非在发现第一个匹配项时立即停止。
- `i` —— 忽略大小写
- `m` —— 多行模式，匹配多行。 

常用正则表达式：

手机号码：`/^1[3456789]\d{9}$/`

电子邮箱：`/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/`

---

## 九、**执行环境及作用域（重要）

​	执行环境 `execution context` ，简称环境，是 `JS` 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。**每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。**虽然通过编码的方式无法访问这个对象，但是解释器在处理数据时会在后台使用它。

​	全局执行环境是最外围的一个执行环境。根据 `ES` 实现所在的宿主环境不同，表示执行环境的对象也不一样。在浏览器中，全局执行环境被认为是 `window` 对象，因此所有全局变量和函数都是作为 `window` 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局作用域直到应用程序退出（比如关闭网页或浏览器）才会销毁。

​	每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境退出，把控制权返回之前的执行环境。

​	当代码再一个环境中执行时，会创建变量对象的一个作用域链。**作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。**作用域链的前端，始终都是当前执行的代码所在环境的变量对象。作用域链中的下一个变量对象来自包含外部环境，而再下一个变量对象则来自下一个包含环境。这样，一致延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。

​	标识符的解析是沿着作用域链一级一级搜索的过程。搜索过程始终都是从作用域链的前端开始，然后逐级往后，知道知道标识符为止，如果到了全局作用域也没有找到，则会抛出错误 。

---

## 十、BOM

​	`BOM`，全称浏览器对象模型，它是一套编程接口，具体体现为五个对象 `window、location、navigator、screen、history` 。

### （一）window 对象

​	`BOM` 的核心是 `window` ，它表示浏览器的一个实例。在浏览器中，`window` 对象有双重角色，它既是通过 `JS` 访问浏览器窗口的一个接口，又是 `ES` 规定的全局对象。因此，**所有在全局作用域中声明的变量、函数都会变成 `window` 对象的属性和方法。**

`window` 对象常用的方法：

- 浏览器位置

  浏览器的位置指的是浏览器左上角相对于显示器左上角的位置。以显示器左上角为原点 （0,0），向右和向下就增大。

  `window.screenX` —— 表示X坐标

  `window.screenY` —— 表示Y坐标

- 浏览器大小

  `window.innerHeight`，`window.innerWidth` 分别表示浏览器的可视高宽，即视口的大小。

  `window.outerHeight`，`window.outerWidth` 分别表示浏览器边框 + 内容区的大小。

### （二）location 对象

​	`location` 提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。它是一个很特别的对象，因为它既是 `window` 对象的属性，也是 `document` 对象的属性。也就是说，`window.location === document.location` 结果是 `true` 的，因为两者引用的是同一个对象。

`location` 对象常用的属性：

- `host` —— 返回服务器名称和端口号
- `hostname` —— 返回不带端口号的服务器名称
- `href` —— 返回当前加载页面的完整 `URL`
- `port` —— 返回端口号
- `protocol` —— 返回页面使用的协议
- `search` —— 返回查询字符串

`location` 对象常用的方法：

- `assign(URL)` —— 立即打开新的 `URL` 并在浏览器历史记录中生成一条记录。如果将 `location.href` 或 `window.location` 设置为一个 `URL` 值，也会调用该方法。
- `replace(URL)` —— 与上面的方法大概一致，不同的是后退不会回到原始的页面。
- `reload()` —— 刷新当前页面

### （三）其余三个对象

`screen` 与 `navigator` 基本不会使用了，而 `history` 还有那么点有趣的玩意。比如：

```js
history.go(1)//前进一页
history.go(2)//前进两页
history.go(-1)//后退一页
history.back()//后退一页
history.forward()//前进一页
```

---

## 十一、DOM

​	`DOM` ，文档对象模型，是一个针对 `HTML` 的编程接口。它描绘了一个层次化的节点树，允许开发者添加、移除和修改页面的某一部分。

### （一）节点层次

#### 1. Node 类型

​	`DOM 1` 中定义了一个 `Node` 接口，该接口由 `DOM` 中的所有节点类型实现。这个 `Node` 接口在 `JS` 中式作为 `Node` 类型实现的，`JS` 中的所有节点类型都继承自 `Node` 类型，用于表名节点的类型。因此所有节点类型都共享着相同的基本属性和方法。每个节点都有一个 `nodeType` 属性，用于表名节点的类型。节点类型由 `Node` 类型中定义了 12 个数值常量来表示，下面只列举常用的几个：

- `Node.ELEMENT_NODE` —— 值为1，表示元素节点
- `Node.ATTRIBUTE_NODE` —— 值为2，表示标签属性节点
- `Node.TEXT_NODE` —— 值为3，表示文本节点
- `Node.DOCUMENT_NODE` —— 值为9，表示文档节点
- `Node.DOCUMENT_FRAGMENT_NODE` —— 值为11，表示文档碎片节点

注意：通过一个节点访问它的 `nodeType` 元素是返回这些具体的数值，而不是他们对应的名字。

​	每个节点都有一个 `childNodes` 属性，其中保存着一个 `NodeList` 对象。`NodeList` 是一个类数组（伪数组）对象，用于保存一组有序的节点，可以通过索引下标来访问这些节点，也有 `length` 属性，但是没有数组的方法。如果需要使用数组的方法，则需要先将这个伪数组转换为数组，转换的方法如下：

- 简单粗暴的 `ES6` ：

  ```js
  let arr = Array.from(box.childNodes)
  ```

- 还是 `ES6` 的语法：

  ```js
  let arr = [...box.childNodes]
  ```

- `ES5` 的方式：

  ```js
  let arr = [].slice.call(box.childNodes)
  //或
  let arr = [].__proto__.slice.call(box.childNodes)
  //或
  let arr = Array.prototype.slice.call(box.childNodes)
  ```

#### 2. Document 类型

​	在 `JS` 中通过 `Document` 类型表示文档。在浏览器中，**`document` 对象是 `HTMLDocument` 的一个实例**，表示整个 `HTML` 页面。`document` 对象是 `window` 对象的一个属性，因此可以将其作为全局对象来访问。`Document` 节点具有下列特征：

- `nodeType` 值为 9
- `nodeName` 值为 `#document`
- `nodeValue` 值为 `null`
- `parentNode` 值为 `null`
- `ownerDocument` 值为 `null`
- 子节点可能是一个 `DocumentType` 或 `Element`，而且最多只有一个。

##### ① `document` 的属性

- 访问子节点的属性

  `document.documentElement` —— 该属性始终指向 `HTML` 页面中的 `html` 元素

  通过 `childNodes[0]` 列表 或 `firstChild` 访问元素。

- 访问基本结构的属性

  通过 `document.head` 可以获取到节点 `head`

  通过 `document.body` 可以获取到节点 `body`

  通过 `document.title` 可以获取到 `title` 标签中的文本，并且可以设置

  通过 `document.doctype` 可以获取到文档声明

  通过 `document.charset` 可以获取并修改字符集

- 访问网页相关的属性

  通过 `document.URL` 可以获取页面的完整 `URL`

  通过 `document.domain` 可以获取页面的域名

  通过 `referrer` 属性可以访问保存着链接到当前页面的那个页面的 `URL`

  通过 `document.readyState` 描述网页是否加载完成，该表达式有两个可能的值：`loading` 表示加载中，`complete` 表示加载完成 

##### ② 查找元素

- `document.getElementById(id)` —— 通过 id 查找元素节点，返回的是一个节点类型
- `document.getElementsByTagName(tagName)` —— 通过 标签名 查找元素节点，返回的是一个类数组，包含着零个或多个元素的 `NodeList` 。
- `document.getElementsByClassName(className)` —— 通过类名查找，返回一个 `nodeList`。
- `document.querySelector(selector)` —— 返回与选择器匹配的第一个元素，如果没有匹配结果，则返回 `null`
- `document.querySelectorAll(selector)` —— 返回包含所有与选择器匹配的元素的 `nodeList`。

#### 3. Element 类型

​	`Element` 类型用于表示 `HTML` 元素，提供了对元素标签名、子节点及特性的访问。`Element` 节点具有以下特征：

- `nodeType` 的值为1
- `nodeName` 的值为元素的标签名，还可以通过 `tagName` 属性来访问

所有 `HTML` 元素都由 `HTMLElement` 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。`HTMLElement` 类型直接继承自 `Element` 并添加一些属性。添加的这些属性分别对应于每个 `HTML` 元素中都存在下列标准特性。

- `id` —— 元素在文档中的唯一标识符
- `title` —— 有关元素的附加说明信息，一般通过工具提示条显示出来
- `lang` —— 元素内容的语言代码
- `className` —— 类名

##### ① 操作标签属性

- `getAttribute(attributeName)` —— 获取标签属性
- `setAttribute(attributeName,value)` —— 设置标签属性
- `removeAttribute(attributeName)` —— 移除标签属性

##### ② 创建元素

通过 `document.createElement(tagName)` 来创建元素。

#### 4. Text 类型

​	文本节点由 `Text` 类型表示，包含的是可以照字面解释的纯文本内容，不能是 `HTML` 代码，它具有以下特性：

- `nodeType` 的值为 3
- `nodeName` 的值为 `#text`
- `nodeValue` 的值为节点所包含的文本

可以通过 `nodeValue` 属性或 `data` 属性访问 `Text` 节点包含的文本，这两个属性中包含的值相同。

### （二）操作样式

​	所有的元素样式都可以通过 **Node.style.attributeName = value** 来访问或修改，但是原生的 `CSS` 属性有的包含 - 符号，在 `DOM` 中只需要转换为小驼峰命名法就可以了。

---

## 十二、事件

​	`JavaScript` 与 `HTML` 之间的交互时通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器来订阅事件，以便事件发生时执行相应的代码。

### （一）事件流

​	事件流描述的是从页面中接收事件的顺序。事件流有以下两种：

- 事件冒泡

  事件冒泡，即事件开始时由最具体的元素接收（文档中嵌套层次最深的节点），然后逐级向上传播到较为不具体的节点（文档）。

- 事件捕获

  事件捕获是跟事件冒泡完全相反的，事件由最不具体的节点向最具体的元素流动。

`DOM 2` 事件规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是事件的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。

### （二）事件处理程序

​	事件就是用户或浏览器自身执行的某种动作。而响应某个事件的函数就称为事件处理程序（事件侦听器）。

- `DOM 0` 事件处理程序

  这是通过 `JS` 指定事件处理程序的传统方式，将一个函数赋值给一个时间处理程序属性。特点：程序中的 `this` 引用当前元素

  `Node.onxxx = function(){}` 其中，xxx表示事件名。

- `DOM 2` 事件处理程序

  `Node.addEventListener(xxx,function(){})` xxx表示事件名。 

  `Node.removeEventListener(xxx)` 移除某个事件处理程序

**两种方式的区别：**

1. `DOM 0` 事件处理程序的同一个属性通能绑定一次；而 `DOM 2` 可以绑定多次，并且都会触发。
2. 移除方式不同，`DOM 0` 直接将引用变量置为 `null` 即可；`DOM 2` 需要使用 `removeEventListener()` 方法
3. 阻止事件冒泡的方式不同，`DOM 0` 可以通过函数的返回值 `return false` 来阻止；而 `DOM 2` 需要通过事件对象的方法来阻止 `e.stopPropagation()` 。

### （三）事件对象

​	在触发 `DOM` 上的某个事件时，会产生一个事件对象 `event` ，这个对象包含着所有与事件有关的信息。事件对象由解释器自动传入回调函数的第一个参数，并且在事件处理程序中生效，事件完成后销毁。

- `event.target` —— 触发事件的目标元素
- `event.stopPropagation()` —— 阻止事件冒泡

---

## 十三、JSON

​	`JSON`，全称为 `JavaScript Object Notation`，它不是一种编程语言，而是一种用于传输的数据格式。`JSON` 的语法可以表示以下三种类型的值：

- 简单值：使用与 `JavaScript` 相同的语法，可以在 `JSON` 中表示字符串、数值、布尔值和 `null`，但 `JSON` 不支持 `JavaScript` 中的特殊值 `undefined`
- 对象：`JS` 中的普通对象
- 数组

两个重要的方法：

- `stringify()` —— 将 `JS` 普通对象转化为 `JSON` 对象
- `parse()` —— 将 `JSON` 对象转为普通对象

---

## 十四、Ajax

​	`Ajax` ，全称为 `Asynchronous JavaScript XML` ，它不是一个新的技术，而是多个技术的整合。这一技术能够向服务器额外的数据而无须卸载页面。它的核心被封装为一个对象 `XMLHttpRequest` 对象（简称 `XHR`）

### （一）XHR 的使用

​	`XHR` 的使用可以大概分为几个步骤：① 实例化 XHR ② 配置

#### 1. 实例化 XHR

​	如今，绝大部分浏览器已经支持原生的 `XHR` ，在这些浏览器中创建 `XHR` 对象只需要一句代码：

```js
let xhr = new XMLHttpRequest();
```

#### 2. 配置请求信息

​	从上面的第一步来看，已经有了 `XHR` 对象了，但是还缺少请求的相关配置。

- 基本配置

  ```js
  xhr.open(method,url,boolean);
  ```

  通过 `open()` 方法配置，它接收三个参数，第一个参数表示请求方式，可以为 `get,post` 等等；第二个参数表示请求的 `url`；第三个参数表示是否异步发送请求，默认值为 `false` ，表示同步发送。

- 配置请求头

  默认情况下，在发送 `XHR` 请求的同时，还会发送下列头部信息：

  - `Accept` —— 浏览器能够处理的内容类型
  - `Accept-Charset` —— 浏览器显示的字符集
  - `Accept-Encoding` —— 浏览器能够处理的压缩编码
  - `Accept-Language` —— 浏览器当前设置的语言
  - `Connection` —— 浏览器与服务器之间连接的类型
  - `Cookie` —— 当前页面设置的任何 `Cookie`
  - `Host` —— 发出请求的页面所在的域名
  - `Referer` —— 发出请求页面的 `URL`
  - `User-Agent` —— 浏览器的用户代理

  **通过 `XHR` 的方法 `setRequestHeader(key,value)` 的方式就可以设置请求头。但是需要注意的是，请求头的配置必须在调用 `open()` 方法之后且调用 `send()` 方法之前。**

- 请求参数

  原生的 `XHR` 发一个请求是非常麻烦的，比如说请求参数，因为查询字符串不能以字符串的方式来表达，查询字符串的每对键值对的 `key` 和 `value` 都必须经过一个函数 `encodeURIComponent()` 加工编码，然后再拼成查询字符串。例如：

  ```js
  xhr.open("get","example.html?name=jonas&age=18",true)//这是无效的，因为查询字符串没有经过洗礼，它是没有灵魂的
  
  //先对查询字符串进行洗礼
  encodeURIComponent("name") + "=" + encodeURIComponent("jonas") + "&"
      encodeURIComponent("age") + "=" + encodeURIComponent("18")
  //然后再将洗礼后的参数拼串成查询字符串，代码略
  ```

  假如对于 `post` 请求携带请求参数，那就更麻烦了，首先需要一个表单，通过表单收集数据，接着将数据序列化（通过 `serialize(form)`），最后将此结果作为 `send()` 的参数。

- 发送请求

  其实在前面已经一直提到这个方法了，`xhr.send()` 

#### 3. XHR的几个重要属性

- `readyState` —— 表示请求/响应过程的当前活动阶段。这个属性的可选值如下：
  - 0 —— 未初始化，尚未调用 `open()` 方法
  - 1 —— 启动，已经调用了 `open()` ，但未调用 `send()`
  - 2 —— 发送，已经调用过 `send()` ，但尚未接收到响应
  - 3 —— 接收，已经接收到部分响应数据
  - 4 —— 完成，已经接收到全部响应数据

- `onreadystatechange` —— 监听 `readyState` 改变的事件处理程序，指向一个回调函数，当 `readyState` 改变时执行。
- `responseText` —— 作为响应主体被返回的文本
- `responseXML` —— 用于响应数据为 `XML`，表示响应数据
- `status` —— 响应的 `HTTP` 状态
- `statusText` —— `HTTP`状态的说明

### （二）**跨域资源共享（重要）

​	通过 `XHR` 实现 `Ajax` 通信的一个主要限制，来源于跨域安全策略。默认情况下，**`XHR` 对象只能访问与包含它的页面位于同一个域中的资源。**这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也至关重要。

​	`CORS`，全称为 `Cross-Origin Resource Sharing`，跨域资源共享，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。`CORS` 背后的基本思想，就是使用自定义的 `HTTP` 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

​	比如一个简单的使用 `get` 或 `post` 发送的请求，它没有自定义的头部，而主体内容是 `text/plain`。在发送该请求时，需要给它附加一个额外的 `Origin` 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。如果服务器认为这个请求可以接受，就在 `Access-Control-Allow-Origin` 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。

​	解决跨域的方式：

- `JSONP` —— 通过 `script` 标签的 `src` 属性发起请求，但是这种方式只能发送 `get` 请求。实现方法：

  ```js
  let script = document.createElement("script");
  script.src = "example.com:80/login?a=a&b=b&callback=cb";
  document.head.appendChild(script);
  function cb(res){//res为响应对象
      //响应逻辑
  }
  ```

  总结：利用了 `script` 标签的 `src` 属性访问外部资源，在 `src` 上注意添加 `callback` 字段绑定响应回调函数。

- `CORS` 

  服务器端设置响应头：

  ```js
  response.setHeader("Access-Control-Allow-Origin","http://example.com:8080")
  ```

---

